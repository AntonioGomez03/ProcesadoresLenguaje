package gec; 
import java_cup.runtime.*; 
import java.io.*; 

/* ----------------Seccion componentes de codigo de usuario--------------*/

parser code {: 
    public static void main(String args[]) throws Exception {

        FileInputStream stream = new java.io.FileInputStream(args[0]); 
        Reader reader = new java.io.InputStreamReader(stream);
        try{

			new parser(new Yylex(reader)).parse();
		}
		catch (Exception e) {
			System.out.println("¡¡ El análisis es INCORRECTO!!");
			System.exit(1);
		}
		System.out.println("¡¡ El Análisis es Correcto !!");
	
		}

    // Recuperación de errores 
    public void report_error(String message, Object info) {
        StringBuffer m = new StringBuffer("Error"); 
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info); 

            if (s.left >= 0) {
                m.append(" en la linea " + (s.left +1)); 
            
            if (s.right >= 0) 
                m.append(", columna "+(s.right+1));
        }
    }
    m.append(" : "+message)
    System.err.println(m)
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info); 
        System.exit(1);
    }
:}

/* ------------Declaracion de la lista de simbolos de la gramatica-----------*/

/* Tokens para palabras reservadas */

terminal DEFINE;
terminal SETUP;
terminal WORLD; 
terminal ADD; 
terminal APPEND; 
terminal SCENE; 
terminal FOR; 
terminal FROM; 
terminal TO; 
terminal IN;
terminal CHUNK;  
terminal GAMEOBJECT; 
terminal LIST;
terminal INT;
terminal FLOAT;
terminal STRING; 
terminal ID;

terminal Integer INT_LITERAL;
terminal Float FLOAT_LITERAL;
terminal String STRING_LITERAL;

terminal OP_ARIT, LPAREN, RPAREN, LBRACE, RBRACE, LSQUARE, RSQUARE, COMMA, LT, GT, ASSIGN;

non terminal program; 
non terminal define_setup; 
non terminal define_world; 
non terminal define_scene;
non terminal statement;
non terminal statement_list; 
non terminal chunck_constuctor;  
non terminal gameobject_constructor; 
non terminal define_list; 
non terminal array; 
non terminal append_statement; 
non terminal add_statement; 
non terminal for_loop_number; 
non terminal for_loop_list; 
non terminal assignment; 
non terminal expression; 
non terminal expression_aux; 
non terminal declaration; 
non terminal define_scene_list;
non terminal id_or_int_literal; 
non terminal id_or_float_literal;
non terminal id_or_string_literal; 
non terminal id_or_array;
non terminal arithmetic_expression;
non terminal chunk_or_gameobject; 
non terminal rest_array;

program ::= define_setup:setup define_world:world_definitions {: 
    System.out.println("Definición del programa completada.");
:};

define_setup ::= DEFINE SETUP LPAREN RPAREN LBRACE statement_list:statements RBRACE {: 
    System.out.println("Setup definido con " + statements.size() + " declaraciones.");
:}
    | DEFINE SETUP LPAREN RPAREN LBRACE RBRACE {: 
    System.out.println("Setup vacío definido.");
:};

statement_list ::= statement:s statement_list:sl {: 
    List<Object> result = new ArrayList<>(s);
    result.add(0, sl);
    RESULT = result;
:}
    | statement:s {: 
    RESULT = new ArrayList<>(List.of(sl));
:};

define_world ::=  DEFINE WORLD LPAREN STRING_LITERAL:name RPAREN LBRACE define_scene_list:scenes RBRACE {:
                world = new World(name);
                for (Scene scene : scenes) {
                world.addScene(scene);
                }
        System.out.println("Mundo definido: " + scenes);
:}
        | DEFINE WORLD LPAREN STRING_LITERAL RPAREN LBRACE RBRACE {: 
        world = new World(name);
        System.out.println("Mundo vacío definido: " + scenes);
:}
                | DEFINE WORLD LPAREN id_or_string_literal RPAREN LBRACE RBRACE;
 
define_scene_list ::= define_scene:scene define_scene_list:sl  {:
                    List<Scene> result = new ArrayList<>(scene);
                    result.add(0, sl);
                    RESULT = result; :}
                    | define_scene:scene {: 
    RESULT = new ArrayList<>(List.of(sl));
:};

define_scene ::= DEFINE SCENE LPAREN STRING_LITERAL:name COMMA INT_LITERAL:width COMMA INT_LITERAL:height RPAREN LBRACE statement_list:statements RBRACE {: 
                Scene scene = new Scene(name, Integer.parseInt(width), Integer.parseInt(height));
                 for (Object stmt : $10) {
        if (stmt instanceof Chunk) {
            scene.addChunk((Chunk) stmt);
        } else {
            System.err.println("Elemento no reconocido en la escena: " + stmt);
        }
    }
    RESULT = scene;
    System.out.println("Escena definida: " + $3);
:}
                | DEFINE SCENE LPAREN STRING_LITERAL COMMA INT_LITERAL COMMA INT_LITERAL RPAREN LBRACE RBRACE {: 
    RESULT = new Scene($3, Integer.parseInt($5), Integer.parseInt($7));
    System.out.println("Escena vacía definida: " + $3);
:};

statement ::= assignment
	| define_list 
	| append_statement
	| for_loop_number
	| for_loop_list
	| declaration
	| add_statement
    | error {: paser.report_error("Error en sintaxis, la sentencia no es valida",null); :};


chunck_constuctor ::= CHUNK LPAREN INT_LITERAL:posX COMMA INT_LITERAL:posY COMMA FLOAT_LITERAL:scale COMMA FLOAT_LITERAL:heightMultiplier COMMA STRING_LITERAL:texture COMMA array:objects RPAREN {: 
    Chunk chunk = new Chunk(posX, posY, scale, heightMultiplier, objects);
    for (Object obj : objects) {
        if (obj instanceof GameObject) {
            chunk.addGameObject((GameObject) obj);
        } else {
            System.err.println("Objeto no reconocido en el chunk: " + obj);
        }
    }
    RESULT = chunk;
    System.out.println("Chunk definido en posición [" + posX + ", " + posY + "]");
:};

gameobject_constructor ::= GAMEOBJECT LPAREN STRING_LITERAL:model COMMA INT_LITERAL:density COMMA FLOAT_LITERAL:scale RPAREN {: 
    RESULT = new GameObject(model, density, scale);
:}
                            | GAMEOBJECT LPAREN STRING_LITERAL COMMA INT_LITERAL COMMA FLOAT_LITERAL COMMA FLOAT_LITERAL RPAREN {: 
    RESULT = new GameObject(model,density, scale);
:};

define_list ::= LIST LT chunk_or_gameobject GT ID ASSIGN array
                | ID ASSIGN array; 

chunk_or_gameobject ::= CHUNK 
                    | GAMEOBJECT;

array ::= LSQUARE gameobject_constructor rest_array RSQUARE {: 
    List<Object> array = new ArrayList<>();
    array.add($2);
    array.addAll($3);
    RESULT = array;
:}
        | LSQUARE chunck_constuctor rest_array RSQUARE {: 
    List<Object> array = new ArrayList<>();
    array.add($2);
    array.addAll($3);
    RESULT = array;
:}
        | LSQUARE RSQUARE {: 
    RESULT = new ArrayList<>();
:};

rest_array ::= COMMA chunck_constuctor rest_array
            |  COMMA ID rest_array
            |  COMMA gameobject_constructor rest_array
            |  COMMA chunck_constuctor 
            |  COMMA ID
            |  COMMA gameobject_constructor;

append_statement ::= APPEND ID ID 
                | APPEND ID gameobject_constructor
                | APPEND ID chunck_constuctor;

add_statement ::= ADD ID 
                | ADD chunck_constuctor; 

for_loop_number ::= FOR ID FROM INT_LITERAL TO INT_LITERAL LBRACE statement_list RBRACE 
                |   FOR ID FROM INT_LITERAL TO INT_LITERAL LBRACE RBRACE; 

for_loop_list ::= FOR ID IN ID LBRACE statement_list RBRACE 
                | FOR ID IN ID LBRACE RBRACE; 

assignment ::= 
      INT ID ASSIGN expression
    | STRING ID ASSIGN expression
    | FLOAT ID ASSIGN expression 
    | ID ASSIGN expression 
    | CHUNK ID ASSIGN chunck_constuctor 
    | ID ASSIGN chunck_constuctor
    | GAMEOBJECT ID ASSIGN gameobject_constructor
    | ID ASSIGN gameobject_constructor;

expression ::= expression_aux arithmetic_expression
            | expression_aux;

arithmetic_expression ::= OP_ARIT expression_aux arithmetic_expression
                        | OP_ARIT expression_aux;

expression_aux ::= STRING_LITERAL
                | INT_LITERAL 
                | FLOAT_LITERAL 
                | ID 
                | LPAREN expression RPAREN; 

declaration ::= INT ID 
            | STRING ID 
            | FLOAT ID 
            | CHUNK ID 
            | GAMEOBJECT ID 
            | LIST LT chunk_or_gameobject GT ID;   

id_or_int_literal ::= ID 
                    | INT_LITERAL; 

id_or_float_literal ::= ID 
                    | FLOAT_LITERAL; 

id_or_string_literal ::= ID 
                    | STRING_LITERAL; 

id_or_array ::= ID  
            | array; 

